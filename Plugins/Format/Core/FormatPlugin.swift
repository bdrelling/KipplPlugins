// Copyright Â© 2022 Brian Drelling. All rights reserved.

import Foundation
import PackagePlugin

@main
struct FormatPlugin {
    private let fileManager = FileManager()

    /// A list of files to exclude by default across all projects.
    ///
    /// These are passed manually as arguments because exclusion rules in files passed via the `--config` option are not respected.
    private let excludedFiles: [String] = [
        // Swift Package Manager
        ".build",
        ".swiftpm",
        "**/Package.swift",
        // CoreData
        "**/*+CoreDataProperties.swift",
        // Example files (eg. for use as blog snippets)
        "**/*.example.swift",
        // Autogenerated files (eg. Sourcery, SwiftGen, Apollo, etc.)
        "**/*.autogenerated.swift",
    ]

    private func perform(
        swiftformat: PluginContext.Tool,
        fileFetcher: PluginContext.Tool,
        defaultSwiftVersion: String,
        workingDirectory: Path,
        arguments: [String],
        targetPaths: ([String]) throws -> [String]
    ) throws {
        var extractor = ArgumentExtractor(arguments)

        let swiftVersion = extractor.option(named: "swiftversion", defaultValue: defaultSwiftVersion)

        // Detect the intended configuration file to use.
        // The order of precedence is as follows:
        //   1. Any file argument passed in should be respected first and foremost.
        //   1. Any file template name argument passed in should be respected second.
        //   3. Any detected file within the working directory where this is executed.
        //   4. The first templated configuration file with a given name.
        //   5. The default templated configuration file.
        let configurationFilePath: String = try {
            if let option = extractor.option(named: "config") {
                return option
            }

            if let templateName = extractor.option(named: "config-template") {
                return try self.templatedConfigurationFilePath(named: templateName, using: fileFetcher)
            }

            let defaultConfigurationFilePath = "\(workingDirectory)/.swiftformat"

            if self.fileManager.fileExists(atPath: defaultConfigurationFilePath) {
                return defaultConfigurationFilePath
            } else {
                // Return the default template file.
                return try self.templatedConfigurationFilePath(named: nil, using: fileFetcher)
            }
        }()

        let isLoggingVerbosely = extractor.flag(named: "verbose")

        let targetNames = extractor.extractOption(named: "target")
        let targets = try targetPaths(targetNames)

        let executablePath = swiftformat.path.string

        if isLoggingVerbosely {
            print("------------------------------------------------------------")
            print("DEBUG INFO")
            print("------------------------------------------------------------")
            print("=> Executable Path:     \(executablePath)")
            print("=> Swift Version:       \(swiftVersion)")
            print("=> Configuration File:  \(configurationFilePath)")
            print("=> Verbose?:            \(isLoggingVerbosely)")
            print("=> Targets:             \(targets)")
            print("=> Arguments:           \(arguments)")
            print("------------------------------------------------------------")
        }

        guard self.fileManager.fileExists(atPath: configurationFilePath) else {
            throw PluginError.configurationFileNotFound
        }

        // Each set of arguments is an array, which is flattened into a single String array before passing into the Process.
        var arguments = [
            // First, include all files that should be formatted.
            !targets.isEmpty ? targets : ["."],
            ["--swiftversion", swiftVersion],
            ["--config", configurationFilePath],
            // SwiftFormat caches outside of the package directory, which is inaccessible to this package, so we cannot cache results.
            // TODO: Investigate alternative directory or system of caching, or open SwiftFormat issue to address?
            ["--cache", "ignore"],
            ["--exclude", self.excludedFiles.joined(separator: ",")],
            extractor.remainingArguments,
        ].flatMap { $0 }

        if isLoggingVerbosely {
            let command = "$ swift run swiftformat \(arguments.joined(separator: " "))"

            print("=> Command:")
            print(command)
            print("------------------------------------------------------------")
        }

        try self.runSwiftFormat(
            executablePath: executablePath,
            arguments: arguments
        )
    }

    private func runSwiftFormat(executablePath: String, arguments: [String]) throws {
        try ConfiguredProcess(
            executablePath: executablePath,
            arguments: arguments
        ).run()
    }

    private func templatedConfigurationFilePath(
        named name: String?,
        using fileFetcher: PluginContext.Tool
    ) throws -> String {
        // Create the arguments array with the first argument -- the name of the tool to fetch a configuration file for.
        var arguments = ["swiftformat"]

        // If name is included, add it to the arguments array.
        // Otherwise, leave it empty and let the executable handle it.
        if let name = name {
            arguments.append(name)
        }

        let process = ConfiguredProcess(
            executablePath: fileFetcher.path.string,
            arguments: arguments
        )

        let output = try process.run()
        let regexPattern = "[A-Z_]*="

        let filePath = output
            .replacingOccurrences(of: regexPattern, with: "", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)

        return filePath
    }
}

// MARK: - Supporting Types

enum PluginError: Error {
    case configurationFileNotFound
}

// MARK: - Extensions

extension ArgumentExtractor {
    mutating func option(named argument: String) -> String? {
        self.extractOption(named: argument).first
    }

    mutating func option(named argument: String, defaultValue: String) -> String {
        self.option(named: argument) ?? defaultValue
    }

    mutating func options(named argument: String) -> [String] {
        self.extractOption(named: argument)
    }

    mutating func option(named argument: String, defaultValues: [String]) -> [String] {
        let options = self.options(named: argument)

        // If options are empty, return the defaultValues array instead.
        return !options.isEmpty ? options : defaultValues
    }

    mutating func flag(named argument: String) -> Bool {
        // The Int value represents the number of occurrences of the flag.
        // Since we won't ever have a use for passing a flag multiple times, we'll just evaluate as a Bool.
        self.extractFlag(named: argument) > 0
    }
}

extension FormatPlugin: CommandPlugin {
    func performCommand(context: PackagePlugin.PluginContext, arguments: [String]) async throws {
        let toolsVersion = context.package.toolsVersion
        let swiftVersion = "\(toolsVersion.major).\(toolsVersion.minor).\(toolsVersion.patch)"

        try self.perform(
            swiftformat: try context.tool(named: "swiftformat"),
            fileFetcher: try context.tool(named: "kipple-file-fetcher"),
            defaultSwiftVersion: swiftVersion,
            workingDirectory: context.package.directory,
            arguments: arguments
        ) { targets in
            try context.package.targets(named: targets).map(\.directory.string)
        }
    }
}

#if canImport(XcodeProjectPlugin)
import XcodeProjectPlugin

extension FormatPlugin: XcodeCommandPlugin {
    func performCommand(context: XcodePluginContext, arguments: [String]) throws {
        try self.perform(
            swiftformat: try context.tool(named: "swiftformat"),
            fileFetcher: try context.tool(named: "kipple-file-fetcher"),
            // FIXME: This needs to detect the version somehow! Detect a .swift-version file, maybe?
            defaultSwiftVersion: "5.7",
            arguments: arguments
        ) { targetNames in
            // It is impossible to provide directories like in Swift Package case
            // because input files in XcodeTarget aren't restricted by a directory.
            let targets = context.xcodeProject.targets.filter { targetNames.contains($0.displayName) }
            return targets.flatMap(\.inputFiles).map(\.path.string)
        }
    }
}
#endif
